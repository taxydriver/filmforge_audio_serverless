import base64
import json
import os
import time
import uuid
import urllib.request
from typing import Any, Dict

import runpod

SERVER_ADDRESS = "127.0.0.1"
CLIENT_ID = str(uuid.uuid4())
MIN_DURATION_SECONDS = 1
MAX_DURATION_SECONDS = 190
MIN_STEPS = 4
MAX_STEPS = 8


def post_json(url: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        url,
        data=data,
        headers={"Content-Type": "application/json"},
    )
    with urllib.request.urlopen(req) as resp:
        return json.loads(resp.read())


def get_json(url: str) -> Dict[str, Any]:
    with urllib.request.urlopen(url) as resp:
        return json.loads(resp.read())


def queue_prompt(prompt: Dict[str, Any], extra_data: Dict[str, Any] | None = None) -> str:
    url = f"http://{SERVER_ADDRESS}:8188/prompt"
    payload: Dict[str, Any] = {"prompt": prompt, "client_id": CLIENT_ID}
    if extra_data:
        payload["extra_data"] = extra_data
    return post_json(url, payload)["prompt_id"]


def wait_for_outputs(prompt_id: str, timeout_s: int = 3600) -> Dict[str, Any]:
    start = time.time()
    while True:
        if time.time() - start > timeout_s:
            raise TimeoutError("Audio generation timeout")

        hist = get_json(f"http://{SERVER_ADDRESS}:8188/history/{prompt_id}")
        if prompt_id in hist and hist[prompt_id].get("outputs"):
            return hist[prompt_id]

        time.sleep(2)


def load_workflow() -> Dict[str, Any]:
    with open("/workflows/audio_trailer.json", "r", encoding="utf-8") as fh:
        return json.load(fh)


def clamp_int(value: int, min_value: int, max_value: int) -> int:
    return max(min_value, min(max_value, value))


def get_comfy_auth_extra_data() -> Dict[str, Any]:
    data: Dict[str, Any] = {}
    auth_token = os.getenv("COMFY_ORG_AUTH_TOKEN")
    api_key = os.getenv("COMFY_API_KEY")
    if auth_token:
        data["auth_token_comfy_org"] = auth_token
    if api_key:
        data["api_key_comfy_org"] = api_key
    return data


def resolve_comfy_file(item: Dict[str, Any]) -> str:
    fullpath = item.get("fullpath")
    if fullpath and os.path.exists(fullpath):
        return fullpath

    filename = item.get("filename")
    if not filename:
        return ""

    subfolder = item.get("subfolder", "") or ""
    out_type = item.get("type", "output") or "output"
    base_dir = {
        "output": "/ComfyUI/output",
        "temp": "/ComfyUI/temp",
        "input": "/ComfyUI/input",
    }.get(out_type, "/ComfyUI/output")

    candidate = os.path.join(base_dir, subfolder, filename)
    if os.path.exists(candidate):
        return candidate

    return ""


def find_audio_file(history: Dict[str, Any]) -> str:
    for _node_id, node in (history.get("outputs") or {}).items():
        for key in ("audio", "audios", "files", "images", "result"):
            for item in node.get(key, []) or []:
                if not isinstance(item, dict):
                    continue
                resolved = resolve_comfy_file(item)
                if resolved:
                    return resolved

    # Fallback: latest MP3 generated by SaveAudio nodes.
    latest_path = ""
    latest_mtime = -1.0
    output_root = "/ComfyUI/output"
    if os.path.isdir(output_root):
        for root, _dirs, files in os.walk(output_root):
            for name in files:
                if not name.lower().endswith(".mp3"):
                    continue
                path = os.path.join(root, name)
                try:
                    mtime = os.path.getmtime(path)
                except OSError:
                    continue
                if mtime > latest_mtime:
                    latest_mtime = mtime
                    latest_path = path
    if latest_path:
        return latest_path

    raise FileNotFoundError("Audio output file not found")


def handler(job: Dict[str, Any]) -> Dict[str, Any]:
    inp = job.get("input") or {}
    prompt_text = inp.get("prompt")
    if not prompt_text:
        return {"error": "input.prompt is required"}

    duration = clamp_int(int(round(float(inp.get("seconds", 30)))), MIN_DURATION_SECONDS, MAX_DURATION_SECONDS)
    seed = int(inp.get("seed", 42))
    steps = clamp_int(int(inp.get("steps", 8)), MIN_STEPS, MAX_STEPS)
    extra_data = get_comfy_auth_extra_data()
    if not extra_data:
        return {"error": "Set COMFY_API_KEY or COMFY_ORG_AUTH_TOKEN in the worker environment."}

    wf = load_workflow()

    # Patch StabilityTextToAudio node input values.
    wf["1"]["inputs"]["prompt"] = prompt_text
    wf["1"]["inputs"]["duration"] = duration
    wf["1"]["inputs"]["seed"] = seed
    wf["1"]["inputs"]["steps"] = steps

    prompt_id = queue_prompt(wf, extra_data=extra_data)
    history = wait_for_outputs(prompt_id)
    audio_path = find_audio_file(history)

    with open(audio_path, "rb") as fh:
        b64 = base64.b64encode(fh.read()).decode("utf-8")

    return {"audio_base64": b64, "format": "mp3"}


runpod.serverless.start({"handler": handler})
